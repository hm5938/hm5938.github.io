---
layout: post
title:  "[C++] 포인터(pointer)"
subtitle: "c++"
categories: dev
tags: dev c++ pointer
comments: true
---


## 개요
> `Pointer` 에 대해 알아보자
  
- 목차
	- [Pointer란?](#Pointer란) 
	- [Pointer 사용하기](#Pointer-사용하기)
	- [포인터와 배열](#포인터와-배열)
	
  
## Pointer란?  
---
point = 가리킨다    
메모리주소는 메모리의 데이터중 특정 위치를 point한다.
따라서 메모리 주소를 다른말로 pointer 라고 부른다.
>`pointer` : 메모리주소, 데이터의 위치정보

* __왜 포인터를 쓸까?__
    - 데이터를 다른 함수로 넘겨줄 때 데이터를 복사해서 주는 것보다 데이터의 위치를 알려주는 것이 더 효
율적이므로
    - 두 개의 서로 다른 함수가 동일한 데이터에 대하여 접근 및 변경하도록 하기 위해서
 

## Pointer 사용하기

* __pointer 변수 선언__
>type형 변수의 주소 값을 저장하는 포인터 변수 ptr의 선언

    ```
    type * ptr;
    ```

 __여기서 잠깐!__

 포인터 변수 선언에서 * 의 위치에 따른 차이는 없다.
 즉, 다음 세 문장은 모두 동일한 포인터 변수의 선언문이다.

```c++
    int * ptr;
    int* ptr;
    int *ptr; 
```

* __pointer 변수의 초기화__

`&` 연산자는 변수의 주소 값을 반환하므로 상수가 아닌 변수가 피연산자이어야 한다.
 `&` 연산자의 반환 값은 포인터 변수에 저장을 한다.

```c++
    int main(void)
    {
        int num =5;
        int * pnum = &num;
    }
```

__여기서 잠깐!__

특정한 값으로 초기화하지 않는 경우에는 `nullptr`로 초기화하는 것이 안전하다. 

    
    int *ptr = nullptr;
    

nullptr는 아무것도 가리키지 않는다는 의미이다.


* __pointer 변수 읽고 변경하기__

포인터가 가리키는 변수의 값을 읽고 쓰기 위해서는 `*`를 쓴다.

    
    * ptr = 변수의 값;
    

__따라서 정리하자면__

```c++
    int a = 1;
    int* p = &a; //a변수의 주소를 p에 저장한다.
    cout << "*p = " << *p << "\n"; //p가 가리키는 변수의 값을 읽는다.
    *p = 2; //p가 가리키는 변수의 값을 변경한다.
    cout << "a = " << a << "\n";
    cout << "*p = " << *p << "\n"; //p가 가리키는 변수의 값을 읽는다.
```

## 포인터와 배열

- 배열을 함수의 인자로 전달하려면 배열을 통째로 복사할 수 있도록 배열이
매개변수로 선언되어야 한다.
- 그러나 C++언어는 매개변수로 배열의 선언을 허용하지 않는다.
- 결론! 배열을 통째로 복사하는 방법은 존재하지 않는다.
- 따라서 배열을 통째로 복사해서 전달하는 방식 대신에, 배열의 주소 값을 전달하는 방식을 대신 취한다. 

```c++
    int main(void)
    {
    int arr[3]={1, 2, 3};
    SimpleFunc(arr);
    
    }
    void SimpleFunc(int * param)
    {
    cout << param[0] << param[1];
    }
```

- 인자와 매개 변수는 서로 다른 메모리 공간에 자리잡고 있는 서로 다른 변수이지만 포인터를 사용하면 서로 같
은 메모리를 사용하는 같은 변수로 만들 수 있다.
- 인자로 변수를 사용하면 값이 복사되어 함수 내에서 인자의 값을 변경해도 함수 밖에서 변경된 값이 반영되지
않는다.
- 인자로 `포인터`를 사용하면 주소가 복사되어 인자와 매개 변수가 같은 메모리 주소의 같은 변수 이므로 `함수 내 에서 인자의 값을 변경하면 함수 밖에서 변경된 값이 유지`된다.
- 포인터와 배열 같이 인자와 매개 변수가 같은 메모리 주소의 같은 변수를 사용하도록 하는 것을 `call by reference`라고 한다.
- 인자와 매개 변수가 함수 호출 시 값만 복제되어 서로 다른 메모리 공간을 사용하는 변수를 사용하는 것을 `call by value`라고 한다.
- 따라서 `call-by-reference` 형태의 함수에서는 외부에 선언된 변수에 접근이 가능하다.

    ```
    arr[i] = *(arr+i)
    ```

__2차원 배열의 전달__

다차원 배열을 인자로 전달할 때에는 맨 앞의 대괄호만 비운다.

```c++
    {% raw %}
    int main()
    {
    int array[5][3] = {{ 1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {10, 11,
    12}, {13, 14, 15} };
    Using2DArray(array);
    }
    void Using2DArray( int arr[][3] )
    {
    for (int i = 0; i < 5; ++i)
    for (int j = 0; j < 3; ++ j)
    cout << "arr[" << i << "][" << j << "] = " << arr[i][j]
    << "\n";
    }
    {% endraw %}
```  

__2차원 배열이름의 포인터 형__

    
    int(*ptr)[3];
    

앞의 2차원 배열의 전달 예제는 배열 포인터 변수를 사용하여 다음과 같이 바꿀 수 있음

```c++    
{% raw %}
void Using2DArray(int(*arr)[3]) // void Using2DArray( int arr[][3] ) 과 동일함

{
for (int i = 0; i < 5; ++i)
for (int j = 0; j < 3; ++j)
cout << "arr[" <<i<< "][" << j << "] = " << (*(arr+i))[j] << "\n";
//cout << "arr[" <<i<< "][" << j << "] = " << arr[i][j] << "\n";
//cout << "arr[" <<i<< "][" << j << "] = " << *(*(arr + i)+j) << "\n";
}
int main()
{
int array[5][3] ={{1, 2, 3} ,{4, 5, 6},{7, 8, 9},{10, 11, 12},{13, 14, 15} };
Using2DArray(array);
}
{% endraw %}
```


